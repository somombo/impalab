use clap::Parser;
use clap::Subcommand;
use std::path::PathBuf;

#[derive(Debug, Parser)]
#[command(version, about = "Orchestrator of Algorithm Benchmarking")]
pub struct Cli {
  #[command(subcommand)]
  pub command: Commands,
}

#[derive(Debug, Subcommand)]
pub enum Commands {
  /// Scans the components directory and builds all found components.
  Build {
    /// Root directory containing component subdirectories.
    #[arg(long, default_value = ".")]
    components_dir: PathBuf,

    /// Output path for the build manifest.
    #[arg(long, default_value = "build_manifest.json")]
    manifest_path: PathBuf,
  },

  /// Runs the benchmark using built components.
  Run(RunArgs),
}

#[derive(Debug, clap::Args)]
pub struct RunArgs {
  /// JSON string mapping languages to lists of function names.
  #[arg(long, required = true)]
  pub algorithms: String,

  /// Seed for the random number generator.
  #[arg(long)]
  pub seed: Option<u64>,

  /// Path to the data generator executable.
  #[arg(long)]
  pub generator_exe_path: Option<PathBuf>,

  /// JSON string mapping languages to sorter executable paths.
  /// Example: '{"cpp": "./sorter_cpp", "lean": "./sorter_lean"}'
  #[arg(long)]
  pub sorter_exe_paths: Option<String>,

  /// Path to the build manifest (generated by the 'build' command).
  /// Used as a fallback if explicit paths aren't provided.
  #[arg(long, default_value = "build_manifest.json")]
  pub manifest_path: PathBuf,

  /// All remaining arguments are passed to the data generator.
  #[arg(trailing_var_arg = true, allow_hyphen_values = true)]
  pub generator_args: Vec<String>,
}
